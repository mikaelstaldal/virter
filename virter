#!/usr/bin/env python3

import argparse
import getpass
import os
import shutil
import subprocess
import tempfile
import time
import uuid
from pathlib import Path
from typing import Optional, List


def main():
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers()

    parser_prepare = subparsers.add_parser("prepare", help="Prepare base image")
    parser_prepare.add_argument("-i", "--image", type=Path, metavar="FILE", help="Image filename", required=True)
    parser_prepare.add_argument("-b", "--base", help="The base to prepare", default="base")
    parser_prepare.add_argument("-m", "--memory", type=int, metavar="MiB", help="Memory in MiB", default=1024)
    parser_prepare.add_argument("-d", "--disk", type=int, metavar="MiB", help="Disk in MiB", default=4096)
    parser_prepare.add_argument("-p", "--packages", nargs='+', metavar="PKG", help="Packages to install", default=[])
    parser_prepare.set_defaults(func=prepare)

    parser_update = subparsers.add_parser("update", help="Update base image")
    parser_update.add_argument("-b", "--base", help="The base to update", default="base")
    parser_update.add_argument("-m", "--memory", type=int, metavar="MiB", help="Memory in MiB", default=1024)
    parser_update.set_defaults(func=update)

    parser_run = subparsers.add_parser("run", help="Run an instance")
    parser_run.add_argument("-n", "--name", help="Name of the instance", default=f"instance-{int(time.time())}")
    parser_run.add_argument("-b", "--base", help="The base to use", default="base")
    parser_run.add_argument("-m", "--memory", type=int, metavar="MiB", help="Memory in MiB", default=1024)
    mounts = parser_run.add_mutually_exclusive_group()
    mounts.add_argument("--mount", type=Path, metavar="DIR", help="Mount a directory in VM read-only")
    mounts.add_argument("--mount-writable", type=Path, metavar="DIR", help="Mount a directory in VM writable")
    mounts.add_argument("--current-dir", action='store_true', help="Mount the current directory in VM read-only")
    mounts.add_argument("--current-dir-writable", action='store_true',
                        help="Mount the current directory in VM writable")
    parser_run.add_argument("COMMAND", nargs="?", help="Command to run")
    parser_run.add_argument("ARG", nargs="*", help="Arguments to command")
    parser_run.set_defaults(func=run)

    args = parser.parse_args()
    if hasattr(args, "func") and args.func:
        args.func(args)
    else:
        parser.print_help()


def prepare(args):
    base_image = args.image
    if not base_image.is_file():
        print("Base image not found")
        exit(1)
    base = args.base
    memory_mib = args.memory
    disk_mib = args.disk
    packages = args.packages
    prepare_or_update(base_image, base, memory_mib, disk_mib, packages)


def update(args):
    base = args.base
    memory_mib = args.memory
    prepare_or_update(None, base, memory_mib, None, [])


def prepare_or_update(base_image: Optional[Path], base: str, memory_mib: int, disk_mib: Optional[int], packages: List[str]) -> None:
    name = base
    vm_uuid = str(uuid.uuid4())

    cache_dir = prepare_cache_dir()

    if base_image:
        shutil.copy(base_image, cache_dir / f"{base}.img")
        subprocess.run([
            "qemu-img",
            "resize",
            "-q",
            str(cache_dir / f"{base}.img"),
            f"{disk_mib}M"
        ],
            cwd=None,
            check=True)
    else:
        if not (cache_dir / f"{base}.img").is_file():
            print(f"Base {base} not found")
            exit(1)

    temp_dir = Path(tempfile.mkdtemp())
    try:
        if base_image:
            cloud_init_prepare(name, temp_dir, packages)
        else:
            cloud_init_update(name, temp_dir)

        run_vm(name, vm_uuid, cache_dir / f"{base}.img", temp_dir / f"{name}-seed.img", memory_mib,
               base_image is not None, None, False)
    finally:
        shutil.rmtree(temp_dir, ignore_errors=True)


def run(args):
    name = args.name
    base = args.base
    memory_mib = args.memory
    mount_dir = args.mount_writable if args.mount_writable is not None \
        else args.mount if args.mount is not None \
        else Path(".") if args.current_dir or args.current_dir_writable else None
    if mount_dir is not None:
        mount_dir = mount_dir.resolve()
        if not mount_dir.is_dir():
            print(f"Directory {mount_dir} not found")
            exit(1)
    mount_readonly = args.mount is not None or args.current_dir

    vm_uuid = str(uuid.uuid4())

    cache_dir = prepare_cache_dir()

    if not (cache_dir / f"{base}.img").is_file():
        print(f"Base {base} not found")
        exit(1)

    temp_dir = Path(tempfile.mkdtemp())
    try:
        subprocess.run([
            "qemu-img",
            "create",
            "-q",
            "-f",
            "qcow2",
            "-b",
            str(cache_dir / f"{base}.img"),
            "-F",
            "qcow2",
            f"{name}.img",
        ], cwd=None, check=True)

        mount_data = f"""bootcmd:
- mkdir -p "{mount_dir}"         
- mount -t virtiofs {"-o ro" if mount_readonly else ""} virtiofs "{mount_dir}"
""" if mount_dir else ""

        username = getpass.getuser()
        command_data = f"""write_files:
- path: \"/home/{username}/.hushlogin\"  
- path: \"/home/{username}/.profile\"
  content: |
    {args.COMMAND} {' '.join(args.ARG)}
    logout    
""" if args.COMMAND else ""

        generate_cloud_init(
            name,
            temp_dir,
            vendor_data=f"""#cloud-config
growpart:
  mode: auto
  devices: [/]
  ignore_growroot_disabled: false
manage_etc_hosts: true
users: []
""" + mount_data + command_data)

        run_vm(name, vm_uuid, Path(f"{name}.img"), temp_dir / f"{name}-seed.img", memory_mib, is_prepare=False,
               mount_dir=mount_dir, mount_readonly=mount_readonly)
    finally:
        img_path = Path(f"{name}.img")
        if img_path.exists():
            img_path.unlink()
        shutil.rmtree(temp_dir, ignore_errors=True)


def cloud_init_prepare(name: str, temp_dir: Path, packages: List[str]):
    username = getpass.getuser()
    cols, rows = shutil.get_terminal_size()
    generate_cloud_init(
        name,
        temp_dir,
        f"""#cloud-config
growpart:
  mode: auto
  devices: [/]
  ignore_growroot_disabled: false
manage_etc_hosts: true
timezone: {read_timezone()}
user:
  name: \"{username}\"
  uid: \"{os.getuid()}\"
  groups: [adm, cdrom, dip, lxd, sudo]
  sudo: [\"ALL=(ALL) NOPASSWD:ALL\"]
  shell: /bin/bash
package_update: true
package_upgrade: true
packages: {packages}
write_files:
- path: /usr/lib/systemd/system/serial-getty@.service  
  content: |
    [Unit]
    Description=Serial Getty on %I
    Documentation=man:agetty(8) man:systemd-getty-generator(8)
    Documentation=https://0pointer.de/blog/projects/serial-console.html
    BindsTo=dev-%i.device
    After=dev-%i.device systemd-user-sessions.service plymouth-quit-wait.service getty-pre.target
    After=rc-local.service
    Before=getty.target
    IgnoreOnIsolate=yes
    Conflicts=rescue.service
    Before=rescue.service    
    [Service]
    ExecStart=-/usr/bin/login -p -f -- {username}
    ExecStart=/sbin/shutdown -h --no-wall now
    Type=oneshot
    Restart=no
    UtmpIdentifier=%I
    StandardInput=tty
    StandardOutput=tty
    TTYPath=/dev/%I
    TTYReset=yes
    TTYVHangup=yes
    TTYColumns={cols}
    TTYRows={rows}
    IgnoreSIGPIPE=no
    SendSIGHUP=yes
    ImportCredential=agetty.*
    ImportCredential=login.*    
    [Install]
    WantedBy=getty.target
- path: /etc/default/grub.d/50-cloudimg-settings.cfg
  content: |
    GRUB_RECORDFAIL_TIMEOUT=0
    GRUB_TIMEOUT=0
    GRUB_CMDLINE_LINUX_DEFAULT="quiet console=ttyS0 systemd.getty_auto=no"
    GRUB_TERMINAL=console      
runcmd:
 - systemctl disable ssh
 - systemctl disable ssh.socket
 - systemctl disable getty@tty1.service
 - systemctl disable serial-getty@ttyS0.service
 - systemctl enable serial-getty@ttyS1.service
 - update-grub 
power_state:
  delay: now
  mode: poweroff
  timeout: 10
  condition: true
"""
    )


def cloud_init_update(name, temp_dir: Path):
    generate_cloud_init(
        name,
        temp_dir,
        f"""#cloud-config
growpart:
  mode: auto
  devices: [/]
  ignore_growroot_disabled: false
manage_etc_hosts: true
users: []
"""
    )


def read_timezone():
    try:
        return Path("/etc/timezone").read_text(encoding="utf-8").strip()
    except FileNotFoundError:
        return ""


def generate_cloud_init(name: str, temp_dir: Path, vendor_data: str):
    (temp_dir / "meta-data").write_text(f"""#cloud-config
instance-id: {name}
local-hostname: {name}
cloud-name: virter
""", encoding="utf-8")
    (temp_dir / "network-config").write_text("""#cloud-config
{}
""", encoding="utf-8")
    (temp_dir / "vendor-data").write_text(vendor_data, encoding="utf-8")
    (temp_dir / "user-data").write_text("""#cloud-config
{}
""", encoding="utf-8")

    subprocess.run([
        "genisoimage",
        "-quiet",
        "-output",
        f"{name}-seed.img",
        "-volid",
        "cidata",
        "-rational-rock",
        "-joliet",
        "meta-data",
        "network-config",
        "vendor-data",
        "user-data",
    ], cwd=(str(temp_dir)), check=True)


def prepare_cache_dir() -> Path:
    cache_home = os.environ.get("XDG_CACHE_HOME", str(Path.home() / ".cache"))
    cache_dir = Path(cache_home) / "virter"
    cache_dir.mkdir(parents=True, exist_ok=True)
    return cache_dir


def run_vm(name: str, vm_uuid: str, image: Path, cloud_init_image: Path, memory_mib: int, is_prepare: bool,
           mount_dir: Optional[Path], mount_readonly: bool):
    virtiofsd = None
    if mount_dir is not None:
        virtiofsd = subprocess.Popen(
            ["/usr/libexec/virtiofsd", "--log-level", "off", "--socket-path", "/tmp/vhostqemu", "--shared-dir",
             mount_dir] + (["--readonly"] if mount_readonly else []))
    subprocess.run(
        [
            "qemu-system-x86_64",
            "-name", name,
            "-uuid", vm_uuid,
            "-pidfile", f"{name}.pid",
            "-cpu", "host",
            "-accel", "kvm",
            "-m", f"{str(memory_mib)}M",
            "-nic", f"user,hostname={name}",
            "-drive", f"file={str(image)},index=0,format=qcow2,media=disk",
            "-drive", f"file={str(cloud_init_image)},index=1,media=cdrom",
            "-sandbox", "on",
            "-nographic",
            "-qmp", "null",
            "-chardev", "stdio,id=stdio,signal=off",
        ] + ([
                 "-serial", "chardev:stdio",
             ]
             if is_prepare else
             [
                 "-serial", "null",
                 "-serial", "chardev:stdio",
             ]) + ([
                       "-chardev", "socket,id=char0,path=/tmp/vhostqemu",
                       "-device", "vhost-user-fs-pci,queue-size=1024,chardev=char0,tag=virtiofs",
                       "-object", f"memory-backend-file,id=mem,size={str(memory_mib)}M,mem-path=/dev/shm,share=on",
                       "-numa", "node,memdev=mem",
                   ] if mount_dir is not None else []),
        cwd=None,
        check=True
    )
    if virtiofsd is not None:
        virtiofsd.wait()


if __name__ == "__main__":
    main()
